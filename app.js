// --- Iris Dataset Loader ---
async function loadIrisDataset() {
  // Public iris CSV (no auth needed)
  const url = 'https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv';
  const res = await fetch(url);
  const text = await res.text();
  const rows = text.trim().split('\n');
  const header = rows[0].split(',');
  const data = rows.slice(1).map(row => {
    const vals = row.split(',');
    return {
      sepal_length: parseFloat(vals[0]),
      sepal_width: parseFloat(vals[1]),
      petal_length: parseFloat(vals[2]),
      petal_width: parseFloat(vals[3]),
      species: vals[4]
    };
  });
  // For demo: use petal_length as X, species as y (setosa=0, versicolor=1, virginica=2)
  window.irisRaw = data;
  const speciesMap = { setosa: 0, versicolor: 1, virginica: 2 };
  X.length = 0; y.length = 0;
  for (const row of data) {
    X.push(row.petal_length);
    y.push(speciesMap[row.species]);
  }
  // Reset all state
  baseModels = [];
  basePredictions = [];
  metaDataset = [];
  metaModel = null;
  // Rerender everything
  renderDatasetTable();
  renderBaseModelsVisual();
  renderBasePredictionsVisual();
  renderMetaDatasetVisual();
  renderMetaModelVisual();
  document.getElementById('base-models-list').innerText = '';
  document.getElementById('base-predictions-list').innerText = '';
  document.getElementById('meta-dataset-output').innerText = '';
  document.getElementById('meta-model-output').innerText = '';
  document.getElementById('final-prediction-output').innerText = '';
  document.getElementById('final-prediction-visual').innerText = '';
  alert('Iris dataset loaded! Use the flow chart to step through stacking.');
}
// --- Interactive Flow Chart ---
const stackingSteps = [
  { key: 'dataset', label: 'Dataset' },
  { key: 'baseModels', label: 'Base Models' },
  { key: 'basePredictions', label: 'Base Predictions' },
  { key: 'metaDataset', label: 'Meta-Model Dataset' },
  { key: 'metaModel', label: 'Meta-Model' },
  { key: 'finalPrediction', label: 'Final Prediction' }
];
let currentStep = 0;

function renderGraphProcess() {
  const steps = [
    { key: 'dataset', label: 'Dataset' },
    { key: 'baseModels', label: 'Base Models' },
    { key: 'basePredictions', label: 'Base Predictions' },
    { key: 'metaDataset', label: 'Meta-Model Dataset' },
    { key: 'metaModel', label: 'Meta-Model' },
    { key: 'finalPrediction', label: 'Final Prediction' }
  ];
  let html = '<div class="graph-process">';
  for (let i = 0; i < steps.length; i++) {
    html += `<div class="graph-node${i === currentStep ? ' active' : ''}" onclick="goToStep(${i})">${steps[i].label}</div>`;
    if (i < steps.length - 1) {
      html += '<div class="graph-arrow">â†“</div>';
    }
  }
  html += '</div>';
  document.getElementById('stacking-graph').innerHTML = html;
}

// Replace renderFlowChart with renderGraphProcess
renderFlowChart = renderGraphProcess;

// Update goToStep to re-render the graph
function goToStep(stepIdx) {
  currentStep = stepIdx;
  renderGraphProcess();
  highlightSectionForStep();
}

function highlightSectionForStep() {
  // Hide all sections except the current one (except flowchart)
  const sectionIds = [
    'dataset-section',
    'base-models-section',
    'base-predictions-section',
    'meta-dataset-section',
    'meta-model-section',
    'final-prediction-section'
  ];
  sectionIds.forEach((id, idx) => {
    const el = document.getElementById(id);
    if (el) el.style.display = (idx === currentStep) ? '' : 'none';
  });
}

// Initial render
renderGraphProcess();
highlightSectionForStep();

// No dataset loads automatically; user must click 'Generate Random Dataset'
// Dataset must be generated by user
const X = [];
const y = [];

let baseModels = [];
let basePredictions = [];
let metaDataset = [];
let metaModel = null;

// --- Visualization functions ---
function renderDatasetTable() {
  let html = '<table border="1" cellpadding="5"><tr><th>Index</th><th>X</th><th>y</th></tr>';
  for (let i = 0; i < X.length; i++) {
    html += `<tr><td>${i+1}</td><td>${X[i]}</td><td>${y[i]}</td></tr>`;
  }
  html += '</table>';
  document.getElementById('dataset-table').innerHTML = html;
}

function renderBaseModelsVisual() {
  let html = '';
  if (baseModels.length > 0) {
    html += '<b>Base Models:</b><ul>';
    const form = document.getElementById('base-models-form');
    if (form.elements['model1'].checked) html += '<li>Model 1: y = 2x</li>';
    if (form.elements['model2'].checked) html += '<li>Model 2: y = 2x + 1</li>';
    if (form.elements['model3'].checked) html += '<li>Model 3: y = 3x</li>';
    if (form.elements['model4'].checked) html += '<li>Model 4: y = x + 5</li>';
    html += '</ul>';
  }
  document.getElementById('base-models-visual').innerHTML = html;
}

function renderBasePredictionsVisual() {
  if (basePredictions.length === 0 || baseModels.length === 0) {
    document.getElementById('base-predictions-visual').innerHTML = '';
    return;
  }
  let html = '<table border="1" cellpadding="5"><tr><th>Index</th><th>X</th>';
  // Table headers for each model
  const form = document.getElementById('base-models-form');
  const modelHeaders = [];
  if (form.elements['model1'].checked) modelHeaders.push('Model 1');
  if (form.elements['model2'].checked) modelHeaders.push('Model 2');
  if (form.elements['model3'].checked) modelHeaders.push('Model 3');
  if (form.elements['model4'].checked) modelHeaders.push('Model 4');
  for (const h of modelHeaders) html += `<th>${h}</th>`;
  html += '</tr>';
  for (let i = 0; i < X.length; i++) {
    html += `<tr><td>${i+1}</td><td>${X[i]}</td>`;
    for (let j = 0; j < baseModels.length; j++) {
      html += `<td>${basePredictions[i][j]}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  document.getElementById('base-predictions-visual').innerHTML = html;
}

function renderMetaDatasetVisual() {
  if (metaDataset.length === 0 || baseModels.length === 0) {
    document.getElementById('meta-dataset-visual').innerHTML = '';
    return;
  }
  let html = '<table border="1" cellpadding="5"><tr><th>Index</th>';
  // Table headers for each model
  const form = document.getElementById('base-models-form');
  const modelHeaders = [];
  if (form.elements['model1'].checked) modelHeaders.push('Model 1 Prediction');
  if (form.elements['model2'].checked) modelHeaders.push('Model 2 Prediction');
  if (form.elements['model3'].checked) modelHeaders.push('Model 3 Prediction');
  if (form.elements['model4'].checked) modelHeaders.push('Model 4 Prediction');
  for (const h of modelHeaders) html += `<th>${h}</th>`;
  html += '<th>Target (y)</th></tr>';
  for (let i = 0; i < metaDataset.length; i++) {
    html += `<tr><td>${i+1}</td>`;
    for (let j = 0; j < baseModels.length; j++) {
      html += `<td>${metaDataset[i].features[j]}</td>`;
    }
    html += `<td>${metaDataset[i].target}</td></tr>`;
  }
  html += '</table>';
  document.getElementById('meta-dataset-visual').innerHTML = html;
}

function renderMetaModelVisual() {
  if (!metaModel || baseModels.length === 0) {
    document.getElementById('meta-model-visual').innerHTML = '';
    return;
  }
  // Show meta-model equation with correct number of base models
  let html = `<b>Meta-model equation:</b><br>y = `;
  for (let i = 0; i < baseModels.length; i++) {
    html += `${metaModel[i+1].toFixed(2)} * Model${i+1}`;
    if (i < baseModels.length - 1) html += ' + ';
  }
  html += ` + ${metaModel[0].toFixed(2)}`;
  document.getElementById('meta-model-visual').innerHTML = html;
}

function renderFinalPredictionVisual(x, preds, y_pred) {
  let html = `<b>Prediction for x=${x}:</b><br>`;
  html += `Model 1: ${preds[0]}, Model 2: ${preds[1]}<br>`;
  html += `<b>Meta-model prediction: ${y_pred.toFixed(2)}</b>`;
  document.getElementById('final-prediction-visual').innerHTML = html;
}

// --- Main logic functions ---
renderDatasetTable();



function generateBasePredictions() {
  if (baseModels.length === 0) {
    alert('Train base models first!');
    return;
  }
  basePredictions = X.map(x => baseModels.map(model => model(x)));
  let html = '<b>Predictions for each sample:</b><br>';
  basePredictions.forEach((preds, i) => {
    html += `Sample ${i+1} (x=${X[i]}): Model 1 = ${preds[0]}, Model 2 = ${preds[1]}<br>`;
  });
  document.getElementById('base-predictions-list').innerHTML = html;
  renderBasePredictionsVisual();
}
window.generateBasePredictions = generateBasePredictions;

function generateRandomDataset() {
  // Generate 50 random (x, y) pairs with a linear-ish relationship and some noise
  X.length = 0;
  y.length = 0;
  for (let i = 0; i < 50; i++) {
    const x = Math.round(Math.random() * 100) / 5 + 1; // x in [1,21]
    // y = 3x + noise
    const noise = (Math.random() - 0.5) * 10;
    X.push(Number(x.toFixed(2)));
    y.push(Number((3 * x + noise).toFixed(2)));
  }
  // Reset all state
  baseModels = [];
  basePredictions = [];
  metaDataset = [];
  metaModel = null;
  // Rerender everything
  renderDatasetTable();
  renderBaseModelsVisual();
  renderBasePredictionsVisual();
  renderMetaDatasetVisual();
  renderMetaModelVisual();
  document.getElementById('base-models-list').innerText = '';
  document.getElementById('base-predictions-list').innerText = '';
  document.getElementById('meta-dataset-output').innerText = '';
  document.getElementById('meta-model-output').innerText = '';
  document.getElementById('final-prediction-output').innerText = '';
  document.getElementById('final-prediction-visual').innerText = '';
  alert('Random dataset generated! Use the process graph to step through stacking.');
}
window.createMetaDataset = createMetaDataset;

function trainMetaModel() {
  if (metaDataset.length === 0) {
    alert('Create meta-model dataset first!');
    return;
  }
  // Simple meta-model: linear regression y = a*model1 + b*model2 + ... + c
  const X_meta = metaDataset.map(row => row.features);
  const y_meta = metaDataset.map(row => row.target);
  if (X_meta.length === 0 || y_meta.length === 0 || baseModels.length === 0) {
    alert('Meta-dataset is empty or no base models selected.');
    return;
}
window.trainMetaModel = trainMetaModel;
window.generateRandomDataset = generateRandomDataset;
  // Add bias term
  const X_aug = X_meta.map(f => [1, ...f]);
  // Compute (X^T X)^-1 X^T y
  const XT = mathTranspose(X_aug);
  const XTX = mathMultiply(XT, X_aug);
  const XTy = mathMultiply(XT, y_meta);
  let XTX_inv;
  try {
    XTX_inv = mathInverse2D(XTX);
  } catch (e) {
    alert('Meta-model training failed: matrix inversion error. Try using more or different base models.');
    return;
  }
  const coeffs = mathMultiply(XTX_inv, XTy);
  // Check for NaN in coefficients
  if (coeffs.some(c => isNaN(c))) {
    alert('Meta-model training failed: coefficients are NaN. Try using more or different base models.');
    return;
  }
  metaModel = coeffs; // [c, a, b, ...]
  document.getElementById('meta-model-output').innerHTML =
    'Meta-model trained: ' +
    coeffs.slice(1).map((c, i) => `${c.toFixed(2)}*Model${i+1}`).join(' + ') +
    ' + ' + coeffs[0].toFixed(2);
  renderMetaModelVisual();
}

function makeFinalPrediction() {
  if (!metaModel || baseModels.length === 0) {
    alert('Train meta-model first!');
    return;
  }
  // For demo, predict for x=11
  const x = 11;
  const preds = baseModels.map(model => model(x));
  let y_pred = metaModel[0];
  for (let i = 0; i < baseModels.length; i++) {
    y_pred += metaModel[i+1] * preds[i];
  }
  if (isNaN(y_pred)) {
    alert('Meta-model prediction failed: result is NaN. Try retraining with different base models or dataset.');
    document.getElementById('final-prediction-output').innerHTML = '';
    renderFinalPredictionVisual(x, preds, NaN);
    return;
  }
  let predText = '';
  for (let i = 0; i < baseModels.length; i++) {
    predText += `Model${i+1}=${preds[i]}`;
    if (i < baseModels.length - 1) predText += ', ';
  }
  document.getElementById('final-prediction-output').innerHTML =
    `For x=11: ${predText}<br>Meta-model prediction: <b>${y_pred.toFixed(2)}</b>`;
  renderFinalPredictionVisual(x, preds, y_pred);
}

// --- Simple matrix math helpers ---
function mathTranspose(A) {
  return A[0].map((_, i) => A.map(row => row[i]));
}
function mathMultiply(A, B) {
  if (Array.isArray(B[0])) {
    // Matrix-matrix
    return A.map(row => B[0].map((_, j) => row.reduce((sum, a, i) => sum + a * B[i][j], 0)));
  } else {
    // Matrix-vector
    return A.map(row => row.reduce((sum, a, i) => sum + a * B[i], 0));
  }
}
function mathInverse2D(M) {
  // Only for 3x3
  const det = M[0][0]*(M[1][1]*M[2][2]-M[1][2]*M[2][1])
            - M[0][1]*(M[1][0]*M[2][2]-M[1][2]*M[2][0])
            + M[0][2]*(M[1][0]*M[2][1]-M[1][1]*M[2][0]);
  const inv = [
    [ (M[1][1]*M[2][2]-M[1][2]*M[2][1])/det, (M[0][2]*M[2][1]-M[0][1]*M[2][2])/det, (M[0][1]*M[1][2]-M[0][2]*M[1][1])/det ],
    [ (M[1][2]*M[2][0]-M[1][0]*M[2][2])/det, (M[0][0]*M[2][2]-M[0][2]*M[2][0])/det, (M[0][2]*M[1][0]-M[0][0]*M[1][2])/det ],
    [ (M[1][0]*M[2][1]-M[1][1]*M[2][0])/det, (M[0][1]*M[2][0]-M[0][0]*M[2][1])/det, (M[0][0]*M[1][1]-M[0][1]*M[1][0])/det ]
  ];
  return inv;
}

// --- Base Models ---
function trainBaseModels() {
  // Get user-selected models from form
  const form = document.getElementById('base-models-form');
  const selected = {
    model1: form.elements['model1'].checked,
    model2: form.elements['model2'].checked,
    model3: form.elements['model3'].checked,
    model4: form.elements['model4'].checked
  };
  if (X.length === 0 || y.length === 0) {
    alert('Please generate a random dataset first!');
    return;
  }
  baseModels = [];
  let modelNames = [];
  if (selected.model1) {
    baseModels.push(x => 2 * x);
    modelNames.push('Model 1 (y=2x)');
  }
  if (selected.model2) {
    baseModels.push(x => 2 * x + 1);
    modelNames.push('Model 2 (y=2x+1)');
  }
  if (selected.model3) {
    baseModels.push(x => 3 * x);
    modelNames.push('Model 3 (y=3x)');
  }
  if (selected.model4) {
    baseModels.push(x => x + 5);
    modelNames.push('Model 4 (y=x+5)');
  }
  if (baseModels.length === 0) {
    document.getElementById('base-models-list').innerText = 'Please select at least one base model.';
    renderBaseModelsVisual();
    return;
  }
  document.getElementById('base-models-list').innerText =
    'Base Models trained: ' + modelNames.join(', ');
  renderBaseModelsVisual();
}

function createMetaDataset() {
  if (basePredictions.length === 0) {
    alert('Generate base model predictions first!');
    return;
  }
  // Meta-dataset: features = base model predictions, target = y
  metaDataset = basePredictions.map((preds, i) => ({
    features: preds,
    target: y[i]
  }));
  let html = '<b>Meta-dataset (first 5 rows):</b><br>';
  metaDataset.slice(0,5).forEach((row, i) => {
    html += `Row ${i+1}: Features = [${row.features.join(', ')}], Target = ${row.target}<br>`;
  });
  document.getElementById('meta-dataset-output').innerHTML = html;
  renderMetaDatasetVisual();
}
window.createMetaDataset = createMetaDataset;
